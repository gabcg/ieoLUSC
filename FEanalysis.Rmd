---
output:
  BiocStyle::html_document
---

<!---
Because we split the analysis pipeline in different independent files,
to speed up processing it, here in the setup block we load libraries and
objects that were loaded or produced in the previously processed file,
and which are necessary in this file.
--->

```{r setup, cache=FALSE, echo=FALSE, results='hide', message=FALSE}
library(knitr)
library(SummarizedExperiment)
library(edgeR)
library(geneplotter)
library(limma)
library(sva)

opts_chunk$set(cache=TRUE,
               cache.path="cache/file2",
               cache.extra=R.version.string,
               autodep=TRUE,
               fig.align="center",
               comment="")

# Raw data
se.unpaired <- readRDS(file.path("rawCounts", "seLUSC.rds"))

# Paired raw data
se <- readRDS(file.path("results", "se.paired.rds"))
dge <- readRDS(file.path("results", "dge.paired.rds"))

# Unnormalized data with low expression genes filtered out
se.gfilt.unnorm <- readRDS(file.path("results", "se.paired.gfilt.unnorm.rds"))
dge.filt.unnorm <- readRDS(file.path("results", "dge.paired.gfilt.unnorm.rds"))

# Normalized data with low expression genes filtered out
se.gfilt.norm <- readRDS(file.path("results", "se.paired.gfilt.norm.rds"))
dge.gfilt.norm <- readRDS(file.path("results", "dge.paired.gfilt.norm.rds"))

# Normalized data with low expression genes and one sample filtered out
se.filt <- readRDS(file.path("results", "se.paired.gsfilt.norm.rds"))
dge.filt <- readRDS(file.path("results", "dge.paired.gsfilt.norm.rds"))

# Differentially expressed genes list
DEgenes <- readRDS(file.path("results", "DEgenes.rds"))
```

# Functional enrichment analysis

## Gene set enrichment analysis (GSEA)

In addition to identifying differential expressed genes by adjusting surrogate variables in the differential expression analysis, a gene set enrichment analysis (GSEA) was also completed. This procedure provides more sensitivity in identifying gene expression changes. This analysis assesses how genes are behaving differently between two phenotypic states (normal vs tumor in this case). The analysis calculates an enrichment score for each gene set which provides information on the changes in gene expression by individual genes in the gene set. 

The first step in running a GSEA is to select a collection of gene sets from the *MSigDB* gene set collections provided by the Broad Institute. The C2 collection contains 3272 computational gene sets, divided into the following two sub-collections: *Chemical and genetic perturbations (CGP)* and *Canonical pathways (CP)*. Most of the first comes from microarray studies, while the second comes from various databases. The C2 collection is well-curated and large, which makes it an ideal candidate to use in the analysis.

```{r message=FALSE}
library(GSEABase)
geneUniverse <- rownames(se.filt)
length(geneUniverse)

library(GSVAdata) 
data(c2BroadSets) 
c2BroadSets
length(c2BroadSets)
```

After the selection of the collection for the GSEA, the next step is to map the identifiers from the `r length(c2BroadSets)` C2 gene sets to the data set being analyzed.

```{r}
gsc <- GeneSetCollection(c(c2BroadSets))

# Map identifiers
gsc <- mapIdentifiers(gsc, AnnoOrEntrezIdentifier(metadata(se.filt)$annotation))
gsc
```

A matrix is created to check if the identifiers were properly mapped, or matched to the corresponding identifier in the data set being analyzed. 

```{r}
Im <- incidence(gsc)
dim(Im)
Im[1:2, 1:10]
Im <- Im[, colnames(Im) %in% rownames(se.filt)]
dim(Im)
```

Since the genes from the data set being analyzed are the only genes of interest, all genes that are not a part of this data set, denoted by a "0", are discarded.  

```{r}
se.filtgsea <- se.filt[colnames(Im), ]
dge.filtgsea <- dge.filt[colnames(Im), ]
dim(dge.filtgsea)
```

This leaves `r dim(dge.filtgsea)[1]` genes to be analyzed among `r dim(dge.filtgsea)[2]` samples. With the data ready, a SVA is completed without calling any gene differentially expressed. The mean-variance is the same from the previous differential expression analysis, so the plot is not displayed.

```{r}
patientid <- substr(colnames(se.filtgsea), 9, 12)
mod <- model.matrix(~type + patientid, data = colData(se.filtgsea))
mod0 <- model.matrix(~patientid, data = colData(se.filtgsea))
sv <- sva(assays(se.filtgsea)$logCPM, mod, mod0)

# Add surrogates to the model
len <- length(colnames(mod))
mod <- cbind(mod, sv$sv)
colnames(mod) <- c(colnames(mod)[1:len], paste0("SV", 1:sv$n))

v <- voom(dge.filt, mod)
fit <- lmFit(v, mod)
fit <- eBayes(fit)
tt <- topTable(fit, coef = 2, n = Inf)
```

With the t-statistics available, the z-scores are then calculated to see if a shift in gene expression within a gene set was present. First, a filter is set that required the gene sets to have a minimum size of 5 genes.

```{r}
Im <- Im[rowSums(Im) >= 5, ]
dim(Im)
```

The t-statistics are then stored in a vector in order of the incidence matrix. The z-score is then calculated and sorted by the absolute score. The z-score of 5 indicates that this gene set is about 5 units above the mean. A low z-score suggests the genes in the gene set are not differentially expressed. 

```{r}
tGSgenes <- tt[match(colnames(Im), rownames(tt)), "t"]
length(tGSgenes)

head(tGSgenes)

zS <- sqrt(rowSums(Im)) * (as.vector(Im %*% tGSgenes)/rowSums(Im))
length(zS)

head(zS)

rnkGS <- sort(abs(zS), decreasing = TRUE)
head(rnkGS)
```

A one sample z-test is performed and a conservative multiple testing adjustment is administered to see if any gene sets are candidates for differentially expressed genes. The reason for completing a multiple testing adjustment is due to gene set overlaps. 

```{r}
pv <- pmin(pnorm(zS), 1 - pnorm(zS))
pvadj <- p.adjust(pv, method = "fdr")
DEgs <- names(pvadj)[which(pvadj < 0.01)]
length(DEgs)
head(DEgs)
```

As shown, `r length(DEgs)` gene sets are differentially expressed. Among them, we see the cancer microenvironment or adrenocortical tumor makers.

## Gene set variation analysis (GSVA)

In addition to the GSEA, a gene set variation analysis (GSVA) is performed. This differs from the standard GSEA by utilizing a gene set by sample matrix rather than a gene by sample matrix. This difference allows for the pathway enrichment for each individual sample to be analyzed.

In order to do this, a matrix is created with the number of gene sets and an enrichment score that indicates sample-wise gene-level summaries of expression. Since gene sets with a small amount of genes do not provide much information, a filter is set to remove those gene sets with 5 or less genes.

```{r message=FALSE}
library(GSVA)
GSexpr <- gsva(assays(se.filt)$logCPM, gsc, min.sz=5, max.sz=300, verbose=FALSE)
dim(GSexpr)
```

With the data ready, a SVA is completed without calling any gene differentially expressed. Some of the names of the gene sets are outputed below.

```{r}
mod <- model.matrix(~se.filt$type + patientid, data = colData(se.filt))
mod0 <- model.matrix(~ patientid, data = colData(se.filt))
svaobj <- sva(GSexpr, mod, mod0)

modSVs <- cbind(mod, svaobj$sv)

corfit <- duplicateCorrelation(GSexpr, modSVs, block = se.filt$cellline)
fit <- lmFit(GSexpr, modSVs)
fit <- eBayes(fit)
tt <- topTable(fit, coef = 2, n = Inf)
DEgs <- rownames(tt[tt$adj.P.Val < 0.01, , drop = FALSE])
length(DEgs)
head(DEgs)
```

The `r length(DEgs)` gene sets that are differentially expressed at 1% FDR are shown in black in Figure \@ref(fig:volcanoplot-GVSA).

```{r volcanoplot-GVSA, echo=FALSE, out.width="800px", fig.cap="Volcano and MA plots for GVSA"}
plot(tt$logFC, -log10(tt$P.Value), xlab="Log2 fold-change", ylab="-log10 P-value", 
     pch=".", cex=2, col=grey(0.75), cex.axis=1, cex.lab=1, las=1)
posx <- tt[tt$adj.P.Val < 0.01, "logFC"] 
posy <- -log10(tt[tt$adj.P.Val < 0.01, "P.Value"]) 
points(posx, posy, pch=".", cex=2, col="black")
```

## Gene Ontology analysis

Finally, a Gene Ontology analysis is completed to see if any differentially expressed genes are associated with certain biological processes defined by the Gene Ontology system. 

First, a parameter object is built that specifies the gene universe of interest, the set of `r length(DEgenes)` DE genes, the ontology, and other information. The ontology selected is *BP*, which matches genes to the Biological Processes associated with the GO Terms.

```{r}
geneUniverse <- rownames(se.filt)
length(geneUniverse)

library(GOstats)
params <- new("GOHyperGParams", geneIds=DEgenes, universeGeneIds=geneUniverse,
            annotation="org.Hs.eg.db", ontology="BP",
            pvalueCutoff=0.01, testDirection="over")
```

In Gene Ontology analysis, GO terms can sometime overlap. Therefore, a conditional test is chosen. An Odds Ratio of *Inf* indicates that all genes within a gene set were differentially expressed.

```{r}
conditional(params) <- TRUE
hgOverCond <- hyperGTest(params)
hgOverCond

goresults <- summary(hgOverCond)
head(goresults)
```

Since significantly enriched gene sets formed by a few genes or a lot of genes are not very reliable, a filter is added so those sets with less than or equal to 5 genes or more than 250 genes are removed. In addition, a filter is set on the Odds Ratio to find any above 1.5, which is a 50% increase over the null Odds Ratio of 1. The table is than ordered by Odds Ratio. 

```{r}
goresults <- goresults[goresults$Size >= 5 & goresults$Size <= 250  & goresults$OddsRatio >= 1.5, ]
goresults <- goresults[order(goresults$OddsRatio, decreasing=TRUE), ]
goresults
```

The table above identifies GO terms of interest from the analysis. Some interesting terms related to lung cancer include signal complex assembly, ceramid transport, positive regulation of cyclin-dependent protein serine/threonine kinase activity, and mRNA splice site selection.

Gene symbols can be added to the GO results, and save the table of results both to HTML and LaTeX with the following code.

```{r message=FALSE}
geneIDs <- geneIdsByCategory(hgOverCond)[goresults$GOBPID]
geneSYMs <- sapply(geneIDs, function(id) select(org.Hs.eg.db, columns = "SYMBOL", key = id, 
    keytype = "ENTREZID")$SYMBOL)
geneSYMs <- sapply(geneSYMs, paste, collapse = ", ")
goresults <- cbind(goresults, Genes = geneSYMs)
rownames(goresults) <- 1:nrow(goresults)

library(xtable)
xtab <- xtable(goresults, align = "l|c|r|r|r|r|r|p{3cm}|p{3cm}|")
print(xtab, file = file.path("results", "goresults.html"), type = "html")
print(xtab, file = file.path("results", "goresults.tex"), type = "latex")
```


## Session information

```{r, message=FALSE}
sessionInfo()
```
