---
output:
  BiocStyle::html_document
---

<!---
The following chunk of code, which should not be shown in the resulting document (echo=FALSE) sets up global processing options, such as forcing 'knitr' to stop when an error in the R code is encountered, caching of the results in the 'cache' directory and asking 'knitr' to figure out automatically the dependencies among code chunks to re-calculate cached results (autodep=TRUE).

Other options could be changing the name of the directory where figures end up ('figure' by default), etc. For a full account of 'knitr' options please consult http://yihui.name/knitr/options

At the end of the chunk a 'cat()' call is made to dump a CSS file that gives a better look-and-feel than the knitr default one. See the source css/ieo.css and the resulting projectTemplate.html to understand where this is being dumpted.
--->


```{r setup, cache=FALSE, echo=FALSE, results='hide', message=FALSE}
library(knitr)

opts_chunk$set(cache=TRUE,
               cache.path="cache/QA",
               cache.extra=R.version.string,
               autodep=TRUE,
               fig.align="center",
               comment="")
```

# Quality assessment

## Data import

The assessment and analysis of lung squamous cell carcinoma starts by importing the raw table of counts.

<!--
The option 'message=FALSE' avoid dumping R messages such as "Loading required package: methods" into the output of the report.
-->

```{r, message=FALSE}
library(SummarizedExperiment)

se.unpaired <- readRDS(file.path("rawCounts", "seLUSC.rds"))
se.unpaired

table(se.unpaired$type)
```

Information can already be obtained. For example, that the file contains `r dim(se.unpaired)[1]` genes from a total of `r dim(se.unpaired)[2]` samples. Of this samples, `r sum(se.unpaired$type == 'tumor', na.rm = TRUE)` are tumor samples and `r sum(se.unpaired$type == 'normal', na.rm = TRUE)` are normal samples, which matches the information of the dataset from The Cancer Genome Atlas (TCGA) program.

Next, the column (phenotypic) data can be explored, which in this case corresponds to clinical variables and their corresponding metadata. For example, the column "type" consists of tumor and normal labels. Other information such as gender, tumor stage, and smoking status are also shown.

In any case, all the possible labels can be accessed with the last line of code of the code block below, which returns two columns of information about the clinical variables. One called `labelDescription` contains a succint description of the variable, often not more self-explanatory than the variable name itself, and the other called 'CDEID' corresponds to the so-called `Common Data Element (CDE)` identifier. This identifier can be use in https://cdebrowser.nci.nih.gov to search for further information about the associated clinical variable using the `Advanced search` form and the `Public ID` attribute search.

```{r}
dim(colData(se.unpaired))
colData(se.unpaired)[1:5, 1:5]
mcols(colData(se.unpaired), use.names=TRUE)
```

The row (feature) data provides information on genes. For the first line of command, the length of each gene and the GC content can be seen. The second line of command provides further information, such as the ranges within individual chromosome.

```{r}
rowData(se.unpaired)
rowRanges(se.unpaired)
```

In this analysis, a comparison between tumor and normal cells was done. For this, the dataset is subsetted to obtain only those samples which come from the same patient but have different type, setting a paired design. This strategy also has the benefit of reducing the possibility of false positives. In order to get them, the following code is executed.

```{r}
# get the number of occurences of each patient
occur <- data.frame(table(substr(colnames(se.unpaired), 9, 12)))

# get those that occur twice
paired_df <- occur[occur$Freq > 1,]
paired <- as.vector(paired_df$Var1)
paired <- paired[2:length(paired)]

mask <- is.element(substr(colnames(se.unpaired), 9, 12), paired)

se <- se.unpaired[ ,mask]

saveRDS(se, file.path("results", "se.paired.rds"))
```

Since this data is unprocessed, a first step of quality assessment and normalization must be performed. To do this, the [edgeR](http://bioconductor.org/packages/edgeR) R/Bioconductor package is loaded. This requires the creation of a `DGEList' object, as the package does not work directly with `SummarizedExperiment` objects. In any case, updates to one of the objects will be reflected in the other.

```{r, message=FALSE}
library(edgeR)

dge <- DGEList(counts=assays(se)$counts, genes=mcols(se))
saveRDS(dge, file.path("results", "dge.paired.rds"))
```

One way of normalizing is to use the counts per million (CPM) values. This value is calculated by dividing the number of counts of each sample by 1 million. Instead of using this directly, the $\log_2$ CPM values of expression are calculated as they have nicer distributional properties than raw counts or non-logged CPM units. This information is stored as an additional assay element to ease their manipulation.

```{r}
assays(se)$logCPM <- cpm(dge, log=TRUE, prior.count=0.5)
assays(se)$logCPM[1:5, 1:5]
```

## Sequencing depth

First, the sequencing depth in terms of total number of sequence read counts
mapped to the genome per sample can be examined. Figure \@ref(fig:libsizes) below shows the
sequencing depth per sample, also known as library size, in increasing order.

<!---
you can control the height and width in pixels of the figure with 'out.height' and 'out.width'. Figures are automatically numbered, to refer to them in the main test you should use the notation shown above as \@ref(fig:xxxx) with xxxx being the label in the code chunk that also gives the filename of the figure. This name must be unique
--->

```{r libsizes, echo=FALSE, out.width="800px", fig.cap="Library sizes in increasing order."}
ord <- order(dge$sample$lib.size/1e6)
barplot(dge$sample$lib.size[ord]/1e6, las=1, ylab="Millions of reads",
                xlab="Samples", col=c("blue", "red")[(se$type[ord] == "tumor") + 1])
legend("topleft", c("tumor", "normal"), fill=c("red", "blue"), inset=0.01)
```

This figure reveals no big changes in sequencing depth between samples. In addition, a uniform distribution of tumor and normal samples is seen across the figure. There is a cluster of normal samples on the right side with a higher CPM, which is not considered as problematic for further analyses. The identifiers of those samples with lower sequencing depth can be obtained using the commands below.

```{r}
sampledepth <- round(dge$sample$lib.size / 1e6, digits=1)
names(sampledepth) <- substr(colnames(se), 6, 12)
sort(sampledepth)
```

## Distribution of expression levels among samples

Next step is to look at the distribution of expression values per sample in terms of logarithmic CPM units. Tumor and normal samples are displayed separately, and are shown in Figure \@ref(fig:distRawExp). Each colored line in the graphs below represent a sample. Both graphs have two modes: the first represents genes not expressed in that sample, while the second represents the genes that are expressed.

<!---
the option echo=FALSE hides the R code. When plotting in general one does not
want to see the code. Options fig.height and fig.width control height and width
of the plot in inches while out.height and out.width do it in the final output
file; see http://yihui.name/knitr/options for full details.
--->

```{r distRawExp, echo=FALSE, fig.height=4, fig.width=10, out.width="800px", fig.cap="Non-parametric density distribution of expression profiles per sample.", message=FALSE}
library(geneplotter)
par(mfrow=c(1, 2))
multidensity(as.list(as.data.frame(assays(se[, se$type == "tumor"])$logCPM)),
                          xlab="log 2 CPM", legend=NULL, main="Tumor samples", las=1)
multidensity(as.list(as.data.frame(assays(se[, se$type == "normal"])$logCPM)),
                          xlab="log 2 CPM", legend=NULL, main="Normal samples", las=1)
```

In both graphs, some genes deviate a little from the rest, so they are noted as potential outliers.

## Distribution of expression levels among genes

To look at the distribution of expression levels across genes, the average expression per gene through all the samples is calculated. Figure \@ref(fig:exprdist) shows the distribution of those values.

```{r exprdist, echo=FALSE, out.width="800px", fig.cap="Distribution of average expression level per gene."}
avgexp <- rowMeans(assays(se)$logCPM)
hist(avgexp, xlab="log2 CPM", main="", las=1)
abline(v=1, col="red", lwd=2)
```

## Filtering of lowly-expressed genes

RNA sequence expression profiles that come from lowly-expressed genes can lead to artifacts in downstream differential expression analyses. Thus, it is common to set a threshold and filter out genes that fall below this value.

In the light of the plot above (Figure \@ref(fig:exprdist)), a cutoff of 1 log CPM unit is considered as the minimum value of expression to select genes being expressed across samples. Using this cutoff we proceed to filter out lowly-expressed genes.

```{r}
mask <- avgexp > 1
dim(se)
se.filt <- se[mask, ]
dim(se.filt)
dge.filt <- dge[mask, ]
dim(dge.filt)
```

A this point, there is a total of `r dim(se.unpaired)[1]` genes and `r dim(se.unpaired)[2]` samples. The un-normalized versions of the filtered expression data are stored.

```{r}
saveRDS(se.filt, file.path("results", "se.paired.filt.unnorm.rds"))
saveRDS(dge.filt, file.path("results", "dge.paired.filt.unnorm.rds"))
```

## Normalization

Next, the normalization factors on the filtered expression data set using the `calcNormFactors` function are calculated.

```{r}
dge.filt <- calcNormFactors(dge.filt)
```

Then, the raw log2 CPM units in the corresponding assay element of the `SummarizedExperiment` object are replaced by the normalized ones.

```{r}
assays(se.filt)$logCPM <- cpm(dge.filt, log=TRUE, normalized.lib.sizes=TRUE, prior.count=0.25)
```

Finally, the normalized versions of the filtered expression data are stored.

```{r}
saveRDS(se.filt, file.path("results", "se.paired.filt.rds"))
saveRDS(dge.filt, file.path("results", "dge.paired.filt.rds"))
```

## MA-plots

MA-plots of the normalized expression profiles allow us to visualize how one sample compares to the average of the rest of the samples, therefore assessing its quality. Ttumor samples are in Figure \@ref(fig:maPlotsTumor).

<!---
Here we make a MA-plot for each sample. The options 'fig.height' and 'fig.width'
control the relative image size in *inches*. The final image size results from
'height'x'dpi' and 'width'x'dpi', where 'dpi' is the image resolution in
"dots per inch" (by default dpi=72). To scale the image to a desired size use
'out.width' and 'out.height'. More information at http://yihui.name/knitr/options
--->

```{r maPlotsTumor, fig.height=36, fig.width=14, dpi=120, echo=FALSE, fig.cap="MA-plots of the tumor samples."}
par(mfrow=c(13, 4), mar=c(4, 5, 3, 1))
setmp <- se.filt[, se.filt$type == "tumor"]
dgetmp <- dge.filt[, se.filt$type == "tumor"]
big_c <- character()
medium_c <- character()
small_c <- character()
for (i in 1:ncol(setmp)) {
  A <- rowMeans(assays(setmp)$logCPM)
  M <- assays(setmp)$logCPM[, i] - A
  samplename <- substr(as.character(colnames(setmp[,i])), 1, 12)
  smoothScatter(A, M, main=samplename,ylim = c(-5,5), las=1)
  abline(h=0, col="blue", lwd=2)
  lo <- lowess(M ~ A)
  lines(lo$x, lo$y, col= if(any(lo$y > 2) || any(lo$y < -2)){"red"} else if (any(lo$y <= 2 & lo$y >= 1) || any(lo$y >= -2 & lo$y <= -1)){"chocolate1"} else if(any(lo$y < 1) || any(lo$y > -1)){"green"}, lwd=2)

if(any(lo$y > 2) || any(lo$y < -2)){ big_c <- append(big_c,samplename)} else if (any(lo$y <= 2 & lo$y >= 1) || any(lo$y >= -2 & lo$y <= -1)){ medium_c <- append(medium_c,samplename)} else if(any(lo$y < 1) || any(lo$y > -1)){small_c <- append(small_c,samplename)}
}
```

The MA-plots of the tumor samples provide the following insight:

* `r length(big_c)` samples with high differences from the mean, with a threshold ( M > 2 or M < -2). Their MA plots have the regression line in red.
* `r length(medium_c)` samples with moderate differences from the mean, which we define as ( M <= 2 and M >= 1 or M >=-2 and M <= -1). Their regression line is brown.
* `r length(small_c)` samples with discrete differences from the mean as they are (M < 1 or M > -1). Their regression line is green.

The appearance of samples that differ from the mean can be problematic. It is worth identifying the name of these samples to keep track of them in subsequent quality assessments. If they probe to be more problematic in downstream analysis, those samples should be removed together with their normal pairs.

```{r}
big_c
```

The normal samples are in Figure \@ref(fig:maPlotsNormal).

```{r maPlotsNormal, fig.height=36, fig.width=14, dpi=120, echo=FALSE, fig.cap="MA-plots of the normal samples."}
par(mfrow=c(13, 4), mar=c(4, 5, 3, 1))
setmp <- se.filt[, se.filt$type == "normal"]
dgetmp <- dge.filt[, se$type == "normal"]
big_n <- character()
medium_n <- character()
small_n <- character()
for (i in 1:ncol(setmp)) {
  A <- rowMeans(assays(setmp)$logCPM)
  M <- assays(setmp)$logCPM[, i] - A
  samplename <- substr(as.character(colnames(setmp[,i])), 1, 12)
  smoothScatter(A, M, main=samplename,ylim = c(-5,5), las=1)
  abline(h=0, col="blue", lwd=2)
  lo <- lowess(M ~ A)
  lines(lo$x, lo$y, col= if(any(lo$y > 2) || any(lo$y < -2)){"red"} else if (any(lo$y <= 2 & lo$y >= 1) || any(lo$y >= -2 & lo$y <= -1)){"chocolate1"} else if(any(lo$y < 1) || any(lo$y > -1)){"green"}, lwd=2)
if(any(lo$y > 2) || any(lo$y < -2)){ big_n <- append(big_n,samplename)} else if (any(lo$y <= 2 & lo$y >= 1) || any(lo$y >= -2 & lo$y <= -1)){ medium_n <- append(medium_n,samplename)} else if(any(lo$y < 1) || any(lo$y > -1)){small_n <- append(small_n,samplename)}
}
```

In this case, the observations are:

* `r length(big_n)` samples with high differences from the mean, with a threshold ( M > 2 or M < -2). Their MA plots have the regression line in red.
* `r length(medium_n)` samples with moderate differences from the mean, which we define as ( M <= 2 and M >= 1 or M >=-2 and M <= -1). Their regression line is brown.
* `r length(small_n)` samples with discrete differences from the mean as they are (M < 1 or M > -1). Their regression line is green.

In conclusion, either important expression-level dependent biases are not observed among the normal samples.

## Batch identification

Batch effects are sub-groups of measurements that have a qualitatively different behavior across conditions and are unrelated to the variables in the study. It is important to determine if batch effects are present to know if any confounding variables are affecting the data.

Potential surrogate of batch effect indicators within normal and tumor samples can be obtained. Given that each sample names corresponds to a TCGA barcode (see https://wiki.nci.nih.gov/display/TCGA/TCGA+barcode), following the strategy described in http://bioinformatics.mdanderson.org/main/TCGABatchEffects:Overview, different elements of the TCGA barcode can be derived from it, and examine their distribution across samples.

```{r}
tss <- substr(colnames(se.filt), 6, 7)
table(data.frame(TYPE=se.filt$type, TSS=tss))

center <- substr(colnames(se.filt), 27, 28)
table(data.frame(TYPE=se.filt$type, CENTER=center))

plate <- substr(colnames(se.filt), 22, 25)
table(data.frame(TYPE=se.filt$type, PLATE=plate))

portionanalyte <- substr(colnames(se.filt), 18, 20)
table(data.frame(TYPE=se.filt$type, PORTIONANALYTE=portionanalyte))

samplevial <- substr(colnames(se.filt), 14, 16)
table(data.frame(TYPE=se.filt$type, SAMPLEVIAL=samplevial))
```

From this information the following observations can be done:

  * All samples were sequenced at the same center
  * Tumor and normal samples were collected in the same vial except one:

```{r}
colnames(se.filt)[samplevial == "01B"]
```

  * Samples were collected evenly across different tissue source sites (TSS).
  * Samples were mostly well distributed in different plates.
  * Samples of normal cells concentrate into two different portion of analyte, while the tumor samples have five different portions.
  
With those results, the portion of analyte is used as a surrogate of batch effect indicator. Considering the outcome of interest as the molecular changes between sample types, tumor vs. normal, the cross-classification of this outcome with portion of analyte are examined.

```{r}
table(data.frame(TYPE=se.filt$type, PORTIONANALYTE=portionanalyte))
```

It is shown how the majority of normal samples (48) come from the "01R"" analyte and 3 come from the "11R" analyte. However, the tumor samples span across five different analytes. This could potentially lead to a batch effect.

In order to examine how the samples group together, two approaches are used here: hierarchical clustering and multidimensional scaling, annotating the outcome of interest and the surrogate of batch indicator, or portion of analyte in this case.

The approaches are performed under a subset of the samples, as it is desirable to have a matrix without zeros. Samples belonging to portions 21R, 31R and 41R are removed, and as the experiment is paired, also their pairs.

```{r}
por1 <- as.vector(substr(colnames(se.filt)[portionanalyte == "41R"], 9, 12))
por2 <- as.vector(substr(colnames(se.filt)[portionanalyte == "31R"], 9, 12))
por3 <- as.vector(substr(colnames(se.filt)[portionanalyte == "21R"], 9, 12))
allpor <- c(por1, por2, por3)

table(is.element(substr(colnames(se.filt), 9, 12), allpor))

se.batch <- se.filt[ ,!is.element(substr(colnames(se.filt), 9, 12), allpor)]
dge.batch <- DGEList(counts=assays(se.batch)$counts, genes=mcols(se.batch))

new.portionanalyte <- substr(colnames(se.batch), 18, 20)
table(data.frame(TYPE=se.batch$type, PORTIONANALYTE=new.portionanalyte))
dim(dge.batch)
```

The code above removed 24 samples, which correspond to the 12 in the indicated portions and their pairs.

The log CPM values are calculated again with a higher prior count to moderate extreme fold-changes produced by low counts. The resulting dendrogram is shown in Figure \@ref(fig:sampleClustering).

```{r sampleClustering, fig.height=7, fig.width=14, dpi=100, echo=TRUE, fig.cap="Hierarchical clustering of the samples."}
logCPM <- cpm(dge.batch, log=TRUE, prior.count=3)
d <- as.dist(1-cor(logCPM, method="spearman"))
sampleClustering <- hclust(d)
batch <- as.integer(factor(new.portionanalyte))
sampleDendrogram <- as.dendrogram(sampleClustering, hang=0.1)
names(batch) <- colnames(se.batch)
outcome <- paste(substr(colnames(se.batch), 9, 12), as.character(se.batch$type), sep="-")
names(outcome) <- colnames(se.batch)
sampleDendrogram <- dendrapply(sampleDendrogram,
                               function(x, batch, labels) {
                                 if (is.leaf(x)) {
                                   attr(x, "nodePar") <- list(lab.col=as.vector(batch[attr(x, "label")]))
                                   attr(x, "label") <- as.vector(labels[attr(x, "label")])
                                 }
                                 x
                               }, batch, outcome)
plot(sampleDendrogram, main="Hierarchical clustering of samples")
legend("topright", paste("Batch", sort(unique(batch)), levels(factor(new.portionanalyte))), fill=sort(unique(batch)))
```

The dendogram shows how samples cluster primarily by sample type, tumor or normal. The different portions are present in both clusters, indicating that they do not induce batch effect. The plot also shows how one of the tumor samples, `8623-tumor`, is present in the normal samples cluster. This sample also had a strong deviation in the MA plot.

In Figure \@ref(fig:mdsPlot) the corresponding MDS plot is shown. It can be seen that the first source of variation separates tumor from normal samples, and there is not  any sample that is separated from any cluster.

```{r mdsPlot, fig.height=7, fig.width=14, dpi=100, echo=TRUE, fig.cap="Multidimensional scaling plot of the samples."}
plotMDS(dge.batch, labels=outcome, col=batch)
legend("bottomleft", paste("Batch", sort(unique(batch)), levels(factor(new.portionanalyte))),
       fill=sort(unique(batch)), inset=0.05)
```

Finally, under the consideration that there is no batch effect, the 24 samples that were removed in order to make the dendogram and the MDS plot will remain for further analysis. Then, the dendogram is generated again in Figure \@ref(fig:allSampleClustering) in order to see if any other sample appears in its opposite cluster, apart from `8623-tumor`.

```{r allSampleClustering, fig.height=7, fig.width=14, dpi=100, echo=TRUE, fig.cap="Hierarchical clustering of the samples."}
logCPM <- cpm(dge.filt, log=TRUE, prior.count=3)
d <- as.dist(1-cor(logCPM, method="spearman"))
sampleClustering <- hclust(d)
batch <- as.integer(factor(portionanalyte))
sampleDendrogram <- as.dendrogram(sampleClustering, hang=0.1)
names(batch) <- colnames(se.filt)
outcome <- paste(substr(colnames(se.filt), 9, 12), as.character(se.filt$type), sep="-")
names(outcome) <- colnames(se.filt)
sampleDendrogram <- dendrapply(sampleDendrogram,
                               function(x, batch, labels) {
                                 if (is.leaf(x)) {
                                   attr(x, "nodePar") <- list(lab.col=as.vector(batch[attr(x, "label")]))
                                   attr(x, "label") <- as.vector(labels[attr(x, "label")])
                                 }
                                 x
                               }, batch, outcome)
plot(sampleDendrogram, main="Hierarchical clustering of samples")
legend("topright", paste("Batch", sort(unique(batch)), levels(factor(new.portionanalyte))), fill=sort(unique(batch)))
```

Again, only the `8623-tumor` sample does not cluster with the rest of the tumor samples. This sample will be removed from the data before further analysis. For this, new files will be saved without those samples.

```{r}

dim(se.filt)
dim(dge.filt)

number <- as.character(8623)

se.filt <- se.filt[ ,!is.element(substr(colnames(se.filt), 9, 12), number)]
dge.filt <- DGEList(counts=assays(se.filt)$counts, genes=mcols(se.filt))

dim(se.filt)
dim(dge.filt)
```

This leaves a number of `r dim(se.filt)[1]` and  `r dim(se.filt)[2]` samples, of which  `r sum(se.filt$type == 'tumor', na.rm = TRUE)` are tumoral and `r sum(se.filt$type == 'normal', na.rm = TRUE)`.

## Session information

```{r, message=FALSE}
sessionInfo()
```
